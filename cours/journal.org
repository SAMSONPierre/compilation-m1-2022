#+TITLE: Compilation 2022/2023 -- Journal du cours
#+AUTHOR: Adrien Guatto
#+EMAIL: guatto@irif.org
#+LANGUAGE: fr
#+OPTIONS: ^:nil p:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \hypersetup{hidelinks}
#+LATEX_HEADER: \usepackage[french]{babel}
# (org-latex-export-to-pdf)

  Ce fichier est disponible au
  [[https://www.irif.fr/~guatto/teaching/22-23/compilation/journal.html][format
  HTML]].

* Cours 01 <2022-09-12>
** Présentation
   Bienvenue en Master 1 !

   |--------+--------------------------------------------+---------------------+---------|
   | Séance | Enseignant                                 | Horaire             | Salle   |
   |--------+--------------------------------------------+---------------------+---------|
   | Cours  | [[mailto:guatto@irif.fr][Adrien Guatto]]   | lundi 10h45-12h45   | SG 1003 |
   | TP     | [[mailto:haberm@irif.fr][Peter Habermehl]] | vendredi 8h30-10h30 | SG 2031 |
   |--------+--------------------------------------------+---------------------+---------|

   *Attention* : les séances de TP commencent la même semaine que les cours !
** Contenu et objectifs du cours
*** Introduction au cours
    En licence, vous avez acquis les bases de l'informatique : appris à
    programmer dans plusieurs langages, découvert l'algorithmique sous diverses
    formes, vous êtes familiarisés avec l'utilisation d'un système UNIX, etc.

    En master, on ouvre les boîtes noires ! Par exemple, le cours d'architecture
    des ordinateurs vous initie au fonctionnement interne d'un processeur.

    Dans ce cours, on ouvre la boîte noire des langages de programmation :
    comment fonctionne un compilateur ? Comment passer d'un fichier texte
    contenant du code source à un programme que votre processeur peut exécuter ?

    Comprendre le fonctionnement des compilateurs est l'objectif affiché du
    cours. Il y en a un deuxième, un peu caché : vous faire programmer, et
    beaucoup ! Vous allez écrire un compilateur, en OCaml, tout au long du
    semestre, en binôme, de façon guidée. Vous allez pour ce faire utiliser des
    méthodes et outils de développement modernes : gestion de version, tests,
    intégration continue, etc.
*** Pourquoi étudier la compilation ?
    Ce n'est pas une compétence directement mobilisable dans la plupart des
    emplois de développeur, même si la demande pour des experts en compilation
    est forte à l'international (exemple : compilation de JavaScript).

    Mais comprendre comment fonctionne un compilateur vous transformera en des
    programmeurs plus mûrs, qui maîtrisent les fondements de leurs outils. C'est
    une aide concrète lorsqu'on programme, et notamment lorsqu'on débogue et
    qu'on a besoin de regarder ``sous le capot''.

    De plus, la compilation est un sujet pluridisciplinaire :
    - architecture des ordinateurs,
    - théorie des graphes
    - théorie des langages et automates,
    - sémantique des langages de programmation,
    - génie logiciel,
    - méthodes formelles...
    Vous allez donc mettre en pratique et revisiter certains concepts que vous
    avez vu dans d'autres cours, ce qui peut vous aider à les assimiler.

    Il va sans dire que la réalisation du projet va aussi beaucoup augmenter
    votre expérience de la programmation. Ce sera pour la majorité d'entre vous
    l'occasion de vous confronter pour la première fois à une base de code
    réaliste !
** Fonctionnement du cours
   Vous avez tous reçu une copie de la description du cours (son /syllabus/,
   dans le jargon), aussi disponible en ligne sur la page du cours. Prenons le
   temps de le lire ensemble.

   Il se dégage plusieurs principes.

   - Les séances de cours sont centrées sur la réalisation du projet, qui
     oriente les concepts que je vais présenter et nos discussions. Elles se
     veulent interactives et ouvertes à la discussion.

   - Le projet est structuré en grandes étapes indépendantes, les /jalons/, qui
     prennent la forme de code à trou : il faudra lire autant qu'écrire !

   - Vous aurez les énoncés des jalons rapidement, et chaque séance de cours
     débutera par 15 à 30 minutes de travail collectif au sujet des questions
     que vous aurez préparées au sujet des jalons.

   - Le bon fonctionnement des jalons sera évalué par une batterie de tests
     automatiques.

   Pour que le cours fonctionne, vos enseignants attendent de vous :

   - que vous travailliez de façon continue et régulière tout le semestre,

   - que vous rendiez vos jalons à temps (toutes les trois semaines environ),

   - que vous prêtiez attention à la qualité du code,

   - en cours : que vous preniez des notes tout en réfléchissant et questionnant
     de façon critique la discussion,

   - en TP : que vous posiez des questions et discutiez avec l'enseignant et vos
     camarades,

   - chez vous : que vous lisiez le code du projet ainsi que les documents
     obligatoires et conseillées, que vous programmiez.

   L'évaluation se fera sur votre compréhension du projet, estimée pour 70% par
   la soutenance, pour 30% par un examen. La soutenance est individuelle, on
   vous demandera d'expliquer votre code, et la qualité de celui-ci sera prise
   en compte.
** Introduction à la compilation : le micro-langage Marthe
   Le reste de la séance est consacré à la lecture et discussion d'un
   micro-langage de programmation, Marthe. Voir le fichier
   [[file:cours-01/marthe.ml][marthe.ml]].
** À préparer pour le prochain TP et le prochain cours
*** TODO Prochaine séance de travaux pratiques
    - Venir avec son ordinateur portable, vendredi
    - S'assurer que celui-ci dispose d'un environnement de développement OCaml
      fonctionnel (compilateur OCaml, OPAM, dune).
*** TODO S'inscrire sur la liste de diffusion du cours
    https://listes.u-paris.fr/wws/info/m1.2022.compilation.info
*** TODO Prochain séance de cours
    - Finir la gestion des commentaires dans ~marthe.ml~.
* Cours 02 <2022-09-19>
** Message de service
   La liste a été configurée correctement, les étudiants et étudiantes peuvent
   désormais s'inscrire avec leur adresse courriel favorite.

   https://listes.u-paris.fr/wws/info/m1.2022.compilation.info
** Le retour de Marthe
   Dans [[file:cours-01/marthe.ml][marthe.ml]], on ajoute les commentaires à
   l'analyseur lexical, et on lit l'analyseur syntaxique.
** Le cours 2
   Voir les [[file:cours-02/cours-02-parsing.pdf][transparents]].
** À préparer pour le prochain TP et le prochain cours
*** TODO Lire la documentation des outils ocamllex et Menhir
    - [[https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html]]
    - [[http://pauillac.inria.fr/~fpottier/menhir/manual.pdf]]
*** TODO Préparer le dépôt du projet
    - Forker le dépôt Git du projet
    https://gaufre.informatique.univ-paris-diderot.fr/aguatto/compilation-m1-2022
    - Passer votre fork du dépôt en visibilité privée
    - Ajouter l'accès à l'équipe enseignante
      - Adrien Guatto @aguatto
      - Peter Habermehl @habermeh
    - Remplir le fichier AUTEURS du dépôt
* Cours 03 <2022-09-26>
** Introduction au jalon 1 et au compilateur flap
   Voir le [[file:../flap][code]] du compilateur Flap, ainsi que l'énoncé du
   [[../jalons/jalon-1.pdf][jalon 1]].
** La prochaine fois
   - On terminera de lire ~marthe.ml~.

   - On commencera une séquence de cours au sujet des langages de programmation.
* Cours 04 <2022-10-03>
** Suivi du projet
*** Pourquoi n'y a-t-il pas de ~if <expr> then <expr>~ dans l'AST Hopix ?
    Une partie du /sucre syntaxique/ est éliminée lors de l'analyse
    syntaxique. C'est le cas du ~if <expr> then <expr>~ qui se /désucre/ de la
    même façon que celui d'OCaml.
*** Comment gérer les positions ?
    Menhir ne connaît pas le fichier source, uniquement le ~lexbuf~. C'est donc
    à l'analyseur lexical de remplir ce dernier correctement pour que
    l'analyseur syntaxique puisse avoir accès à l'information de position. Voir
    le type ~Lexing.lexbuf~ pour cette information de position.

    L'analyseur lexical doit essentiellement détecter les nouvelles lignes pour
    mettre à jour le ~lexbuf~. Cf. ~Lexing.new_line~, déjà utilisée dans le
    fichier l'analyseur lexical fourni.

    Les règles de l'analyseur syntaxique peut ensuite utiliser les variables
    Menhir ~$startpos~ et ~$endpos~. Dans le fichier fourni, leur utilisation
    passera par la règle paramétrique ~located(X)~.

    #+BEGIN_VERBATIM
%inline located(X): x=X {
  Position.with_poss $startpos $endpos x
}
    #+END_VERBATIM

    On peut utiliser cette règle pour analyser une valeur de type ~'a
    located~. Par exemple, le non-terminal ~located(expression)~ produit une
    valeur de type ~'a located~.
*** Questions diverses
    J'apporte quelques précisions à l'énoncé du jalon 1.
** Introduction à la théorie des langages de programmation
   Voir la première partie des
   [[file:cours-04-à-06/cours-04-à-06-intro-semantique-typage.pdf][transparents]]
   dédiés. La substitution (derniers transparents) sera traitée à la prochaine
   séance.
* Cours 05 <2022-10-10>
** Suivi du projet
*** À propos des erreurs
    Les erreurs doivent de syntaxe doivent être levées via la fonction
    ~Error.error~, à laquelle il faut passer une position valide.
*** À propos des positions
    Les positions générées dans les messages d'erreur peuvent dépendre de
    détails de la structure de votre grammaire. Il n'est donc pas gênant que
    vous n'ayez pas exactement les mêmes messages que ceux présents dans les
    tests fournis avec le jalon.
** Les réponses aux exercices de code du cours 4
   #+BEGIN_SRC ocaml
     let rec free_vars =
       let open IdSet in
       function
       | EInt i -> empty

       | EVar x -> singleton x

       | EPlus (m, n) | EMult (m, n) -> union (free_vars m) (free_vars n)

       | ESum (x, start, stop, body) ->
          union (union (free_vars start) (free_vars stop))
            (diff (free_vars body) (singleton x))
     ;;

     let fresh_in : IdSet.t -> id =
       fun s ->
       let rec loop i =
         let x = "x" ^ string_of_int i in
         if IdSet.mem x s then loop (i + 1) else x
       in
       loop 0
     ;;

     let rec rename : e -> id -> id -> e =
       fun m y x ->
       match m with
       | EInt _ -> m

       | EVar z -> if z = x then EVar y else m

       | EPlus (m, n) ->
          EPlus (rename m y x, rename m y x)

       | EMult (m, n) ->
          EMult (rename m y x, rename n y x)

       | ESum (z, start, stop, body) ->
          let start = rename start y x in
          let stop = rename stop y x in
          if z = x then ESum (z, start, stop, body)
          else
            let k = fresh_in IdSet.(union (free_vars body) (singleton y)) in
            ESum (k, start, stop, rename (rename stop k z) y x
     ;;

     let rec alpha_eq : e -> e -> bool =
       fun m n ->
       match m, n with
       | EInt _, EInt _ | EVar _, EVar _ ->
          m = n

       | EPlus (m, n), EPlus (m', n') | EMult (m, n), EMult (m', n') ->
          alpha_eq m m' && alpha_eq n n'

       | ESum (x, start, stop, body), ESum (x', start', stop', body') ->
          alpha_eq start start' && alpha_eq stop stop'
          && let y = fresh_in (IdSet.union (free_vars body) (free_vars body')) in
             alpha_eq (rename body y x) (rename body' y x')
     ;;

     let subst : e -> id -> e -> e =
       fun n m x ->
       match n with
       | EInt _ -> n

       | EVar z -> if z = x then m else EVar z

       | EPlus (n1, n2) ->
          EPlus (subst n1 m x, subst n2 m x)

       | EMult (n1, n2) ->
          EMult (subst n1 m x, subst n2 m x)

       | ESum (z, start, stop, body) ->
          let start = subst start m x in
          let stop = subst stop m x in
          if z = x then ESum (z, start, stop, body)
          else
            let k = fresh_in IdSet.(union (free_vars body) (free_vars m)) in
            ESum (k, start, stop, subst (rename stop k z) m x
     ;;
   #+END_SRC
** Introduction à la théorie des langages de programmation
   Voir la deuxième partie des
   [[file:cours-04-à-06/cours-04-à-06-intro-semantique-typage.pdf][transparents]]
   dédiés. On a traité la substitution de la première partie.
* Cours 06 <2022-10-17>
** Introduction au jalon 2
   On discute en détail l'énoncé du deuxième jalon, qui consiste en l'écriture
   d'un inteprète pour Hopix.
** Introduction à la théorie des langages de programmation
   Voir la troisième et dernière partie des
   [[file:cours-04-à-06/cours-04-à-06-intro-semantique-typage.pdf][transparents]]
   dédiés.
* Cours 07 <2022-10-24>
** Jalon 3
   On passe la séance à discuter de l'énoncé du jalon 3, à rendre pour dans
   trois semaines. Le pseudo-code OCaml suivant a été donné.

   #+BEGIN_SRC ocaml
let rec type_of_expression : typing_environment -> expression -> aty =
  fun Γ e ->
  match e with
  (* Exemple : le cas de l'addition. N.B. : ce cas n'existe pas en Hopix, car
     l'addition n'y est pas primitive. On vous le donne parce qu'il s'agit sans
     doute du constructeur d'expression le plus simple à typer qui soit, hormis
     celui correspondant aux constantes littérales. *)
  | Add (e₁, e₂) ->
    (*
      Γ ⊢ e₁ : int    Γ ⊢ e₂ : int
      ----------------------------
           Γ ⊢ e₁ + e₂ : int
     *)
    check_type_expression Γ e₁ ATyInt;
    check_type_expression Γ e₂ ATyInt;
    ATyInt

  (* Exemple : le cas de l'application. *)
  | Apply (e₁, e₂) ->
    (*
      Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
      -------------------------------
             Γ ⊢ e₁ e₂ : τ₂
     *)
    begin match type_of_expression Γ e₁ with
    | ATyArrow (τ₁, τ₂) ->
      check_type_expression Γ e₂ τ₁;
      τ₂
   | _ -> erreur ()
   end

  (* Exemple : le cas de la fonction, qui a besoin d'une annotation. *)
  | Fun (x, Some τ₁, e) ->
    (*
          Γ, x : τ₁ ⊢ e : τ₂
      -------------------------
      Γ ⊢ fun (x : τ₁) → e : τ₂
     *)
    check_well_formed_type Γ τ₁;
    let τ₂ = type_of_expression (Env.add x τ₁ Γ) e₂ in
    ATyArrow (τ₁, τ₂)

  (* Exemple : le cas de la variable, qui a besoin d'une annotation. *)
  | Var (x, Some types) ->
    (*
      Γ(x) = ∀α₁,...,αₙ.τ   Γ ⊢ τ₁   ...   Γ ⊢ τₙ
      --------------------------------------------
         Γ ⊢ x^[τ₁;...;τₙ] : τ[α₁\τ₁,...,αₙ\τₙ]
     *)
    let Scheme (ts, ty) = Env.lookup Γ x in
    List.iter check_wellformed_type types;
    HopixTypes.instantiate (Scheme (ts, ty)) types

and check_type_expression Γ e τ =
  let τ' = type_of_expression Γ e in
  if not (τ = τ') then erreur ()
   #+END_SRC
* Cours 08 <2022-11-07>
** Programmation en assembleur x86-64
*** Contexte : culture générale en architecture des processeurs
    On doit faire attention à distinguer /architecture/ et /micro-architecture/.

    L'architecture, ou /Instruction Set Architecture/ est une abstraction
    permettant la programmation système ou applicative. Exemple : architecture
    x86-64, architecture ARMv8, architecture RISC-V, etc.

    La micro-architecture est une implémentation (ou famille d'implémentations)
    d'une architecture. Par exemple, la micro-architecture Zen 3 d'AMD pour
    x86-64, la micro-architecture Vortex/Tempest d'Apple pour ARMv8, la
    micro-architecture U8 de SiFive pour RISC-V.

    Par extension, le terme "micro-architecture" désigne également l'étude des
    techniques d'implémentation efficaces des processeurs.

    Dans ce cours, en tant que spécialistes du logiciel, on s'intéressera à
    l'architecture plutôt qu'à la micro-architecture.

    Deux types d'architectures s'affrontent depuis ~1980 : RISC et CISC.

    RISC = /Reduced Instruction Set Computer/. Offre un petit nombre
    d'instructions simples et orthogonales, ce qui permet de simplifier la
    micro-architecture. Exemple : RISC-V, ARM (historiquement).

    CISC = /Complex Instruction Set Computer/. Beaucoup d'instructions baroques
    et complexes, micro-architecture complexe (décodage). Exemple
    paradigmatique : x86 (32 bits) et x86-64. Les ARM modernes s'en
    rapprochent.

    On va s'intéresser à x86-64, une architecture à la longue évolution.

    #+BEGIN_EXAMPLE
               8086 (16bits)    x86 (32bits)    AMD64 (64bits)
     |—————————————|——————————————|———————————————|—————————————|—————————>
    1970          1980           1990           2000          2010
    #+END_EXAMPLE

    Pourquoi générer du code x86-64 ?

    Inconvénients : complexe, baroque, laid.

    Avantages : réaliste. Vous permet d'exécuter du code sur votre PC, sans
    passer par une couche d'émulation (sauf si vous avez un Mac récent). On ne
    fait pas semblant !

    La documentation à laquelle nous pouvons nous référer :

    - Les [[http://web.cecs.pdx.edu/~apt/cs491/x86-64.pdf][notes d'Andrew
      Tolmach]] sur un tout petit sous-ensemble du jeu d'instructions que nous
      allons utiliser. Leur lecture est *obligatoire*.

    - La documentation combinée d'Intel (5000+ pages), disponible sur la
      [[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html][page]]
      du constructeur.
*** L'état du processeur
    Les instructions x86-64 servent à modifier l'état du processeur qui, en ce
    qui nous concerne, est formé des données suivantes.

    *Attention* : deux syntaxes pour le code assembleur x86-64 existent : Intel
    et GNU/AT&T. Nous utiliserons la syntaxe GNU/AT&T, comme Andrew Tolmach,
    mais beaucoup de documenation utilise la syntaxe Intel.
**** Les registres
    Un registre est un petit emplacement mémoire non-adressable situé
    directement sur le processeur. Y accéder est très rapide.

    En x86-64, on dispose de seize registres généraux de 64 bits, baptisés %rax,
    %rbx, %rcx, %rdx, %rbp, %rsp, %rdi, %rsi, %r8, %r9, %r10, %r11-%r15.

    Il y a des registres 32 bits %eax, %ebx, etc. ainsi que 16 bits %ax, %bx,
    etc. Le contenu de ces petits registres est identique aux bits de poids
    forts de %rax, %rbx, etc. Autrement dit, ces registres sont des /alias/,
    par exemple modifier %ax modifie %eax et modifier %eax modifie %rax.

    En plus, on a des registres spécifiques dans lesquels on ne peut pas lire,
    par exemple %rip le pointeur d'instruction courant, ou %rflags qui contient
    un champ de bits donnant des informations sur les résultats arithmétiques
    (génération d'un overflow, etc.).
**** La mémoire

     Elle est découpée en différentes zones, dont la pile d'exécution.

     Les entiers sont représentés en petit-boutien (/little-endian/), autrement
     dit les bits de poids forts sont stockés aux adresses les plus basses. Pour
     plus de détails, consulter
     [[https://fr.wikipedia.org/wiki/Endianness][Wikipédia]].

     On lit et écrit dans la mémoire principalement via l'instruction ~mov~ :
     ~mov SRC, DST~.

     On peut spécifier une adresse mémoire source *ou* destination via un /mode
     d'adressage/ complexe. Pour ce qui nous occupe, le mode d'adressage le plus
     utile sera ~OFFSET(BASE, INDEX, SCALE)~ où :

     - ~OFFSET~ est une valeur immédiate,

     - ~BASE~ est un registre,

     - ~INDEX~ est un registre optionnel,

     - ~SCALE~ est un entier optionnel pris dans l'ensemble { 1, 2, 4, 8 }.

     Quelques exemples :

     - ~movq $42, %rax~ écrit l'entier 42 dans %rax.

     - ~movq %rbx, -8(%rsp)~ écrit le contenu de %rbx dans la mémoire à
       l'adresse ~%rsp - 8~.

     *Attention* : l'instruction ~mov~ n'autorise pas les transferts de mémoire
     à mémoire. En d'autres termes, un seul des opérandes peut accéder à la
     mémoire par instruction. Par exemple, ~movq (%rax), (%rbx)~ est invalide.

     Il y a plusieurs variantes de l'instruction ~mov~, selon la taille des
     données à transférer : ~movq~, ~movl~, ~movw~, ~movb~. Ici, ~q~ = quad = 64
     bits, ~l~ = long = 32 bits, ~w~ = word = 16 bits, ~b~ = byte = 8 bits.
*** Les instructions
**** Les instructions arithmétiques et logiques
     Les instructions arithmétiques et logiques, comme ~add~, autorisent aussi
     les opérandes mémoires. C'est une des différences entre CISC et RISC.

     Tout comme ~mov~, les instructions arithmétiques et logiques sont
     disponibles en variantes ~q~, ~l~, ~w~ et ~b~.

     Les instructions arithmétiques peuvent modifier le registre ~rflags~, dont
     le contenu est spécifié par la table suivante.

     |-----+-----------------+------------|
     | bit | signification   | mnémonique |
     |-----+-----------------+------------|
     |   0 | Retenue         | CF         |
     |   1 | Parité          | PF         |
     |   6 | Zéro            | ZF         |
     |   7 | Signe (1 = neg) | SF         |
     |  11 | Overflow        | OF         |
     |-----+-----------------+------------|

     Quelques instructions :

     - ~addq SRC, DST~ : calcule ~SRC + DST~ et stocke le résultat dans ~DST~ en
       mettant à jour ~rflags~.

     - ~cmpq SRC1, SRC2~ : calcule ~SRC2 - SRC1~, ignore le résultat mais met à
       jour ~rflags~.

     Je réfère aux notes d'Andrew Tolmach pour détails et autres instructions.
**** Instructions de contrôle
     Elles permettent de modifier le flot d'exécution (la prochaine instruction
     à exécuter). En voici quelques-unes :

     - ~jmp foo~ : saut inconditionnel direct à ~foo~.

     - ~jmp *%rax~ : saut inconditionnel indirect à l'adresse contenue dans
       ~%rax~.

     On verra les instructions restantes lors de la prochaine séance.
* Cours 09 <2022-11-14>
** Programmation x86-64, suite et fin
*** Les instructions
    - ~je foo~ : saute vers ~foo~ si le flag ZF de ~rflags~ est à 1.

    - ~call foo~ : saute vers ~foo~ en empilant ~rip~.

    - ~ret~ : dépile une valeur et la stocke dans ~rip~.

    *Attention* : à l'exécution d'une instruction de saut, %rsp+8 doit toujours
    être aligné sur 16 octets. Donc, %rsp doit être aligné sur 16 octets avant
    toute instruction ~call~, puisque celle-ci va pousser l'adresse de retour.

    Pour comprendre les deux dernières instructions, il faut discuter de la
    pile, ce qu'on va faire tout de suite. Pour les autres, je vous renvoie aux
    notes d'Andrew Tolmach.
*** Convention d'appel et gestion de la pile
    Une architecture doit spécifier une /convention d'appel/, qui dicte le
    fonctionnement des appels de fonction dans le but de permettre
    l'interopérabilité entre différents compilateurs, voire entre différents
    langages.

    Nous allons utiliser la convention d'appel dictée par l'interface binaire
    (/application binary interface/, ou ABI) POSIX System V pour x86-64.

    Celle-ci spécifie l'usage d'une pile pour stocker certains arguments de
    fonction, ainsi que les variables locales. Le sommet courant de la pile
    (son adresse) est, par convention, stocké dans le registre %rsp (/register
    stack pointer/, logique !). Cette adresse doit toujours être alignée sur
    huit octets (multiple de huit). La pile croît vers les adresses basses.

    Un appel de fonction stocke ses données dans son /cadre de pile/. Le cadre
    de pile courant est stocké dans le registre %rbp (/register base pointer/).
    Elle ne doit pas accéder au reste de la pile (à l'exception de ses
    arguments, voire plus bas).

    Pour travailler sur la pile, on peut utiliser les instructions ~push~ et
    ~pop~. L'instruction ~pushq SRC~ correspond à la séquence d'instructions
    ~subq $8, %rsp; movq SRC, (%rsp)~, l'instruction ~popq DST~ correspond à
    la séquence d'instructions ~movq -8(%rsp), DST; addq $8, %rsp~.

    La valeur de retour de la fonction est stockée dans %rax. Les six premiers
    arguments sont stockés dans %rdi, %rsi, %rdx, %rcx, %r8, %r9. Tous les
    autres arguments (au delà du sixième) sont empilés de droite à gauche.

    Les registres %rbx, %rbp %r12, %r13, %r14 et %r15 doivent être préservé par
    l'appelé. Donc, si votre fonction les modifie, elle doit faire en sorte de
    les restaurer avant de. Les autres registres sont susceptibles d'être
    modifiés par les appelés arbitrairement, gare donc si vous les utilisez
    autour d'un appel de fonction !

    |------------+---------------------------|
    | *Pile*     | (Valeurs de %rbp et %rsp) |
    |------------+---------------------------|
    | ...        |                           |
    | argN       |                           |
    | argN-1     |                           |
    | ...        |                           |
    | arg8       |                           |
    | arg7       |                           |
    | saved %rip |                           |
    |------------+---------------------------|
    | saved %rbp | <- %rbp                   |
    | local var1 |                           |
    | ...        |                           |
    | local varN | <- %rsp                   |
    |------------+---------------------------|

    Enfin, l'invariant suivant doit *toujours* être vérifié : lors d'un ~call~,
    %rsp doit être aligné sur 16 octets (autrement dit, sa valeur doit être une
    adresse multiple de 16). Donc, comme ~call~ empile %rip, on sait que la
    valeur %rsp+8 est alignée sur 16 octets au point d'entrée de toute fonction.

    Pour les curieux et curieuses qui voudraient connaître le pourquoi du
    comment, vous pouvez lire les réponses à
    [[https://stackoverflow.com/questions/33868498/whats-the-purpose-of-stack-pointer-alignment-in-the-prologue-of-main][cette
    question]] sur StackOverflow.
*** Quelques exemples
    On a étudié des rudiments de programmation x86-64 lors de la dernière
    séance, et lors de la séance de TP. Essayons de mettre en pratique
    aujourd'hui ensemble.
**** Factorielle itérative
     On écrit le code de factorielle dans un style itératif, avec une boucle. Le
     code C, pour se fixer les idées :

 #+BEGIN_SRC C
   int64_t fact(int64_t n) {
     int64_t res = 1;
     while (n > 1) {
       res *= n--;

     }
     return res;
   }
 #+END_SRC
***** Solution
 #+BEGIN_SRC asm
      fact:   movq $1, %rax
      fact0:  cmp $1, %rdi
              jle fact1
              imulq %rdi, %rax
              dec %rdi
              jmp fact0
      fact1:  ret
 #+END_SRC
**** Fonction principale
     On souhaite appeler ~printf()~ pour afficher le résultat de
     ~fact(6)~. Attention aux contraintes d'alignement de l'ABI System V !
***** Solution
 #+BEGIN_SRC asm
     msg:    .string "fact(6) = %d\n"
     .global main
     main:   subq $8, %rsp
             movq $6, %rdi
             call factr
             movq $msg, %rdi
             movq %rax, %rsi
             call printf
             movq $0, %rdi
             call exit
 #+END_SRC
** De Retrolix à x86-64
*** Retrolix
    Le code relatif à Retrolix est contenu dans
    [[file://../flap/src/retrolix][src/retrolix/]]. Commencer par lire l'AST
    présent dans ~retrolixAST.ml~, puis en cas de question, regarder la
    sémantique de référence dictée par l'interprète dans retrolixInterpreter.ml.

    Il s'agit d'un langage presque aussi bas niveau que l'assembleur, mais pas
    tout à fait. Quelques caractéristiques :

    - des registres (x86-64) *et* des variables (locales, globales, paramètres),

    - le registre matériel %r15 est *réservé* (jamais utilisé),

    - respecte la convention d'appel en ce qui concerne les registres (registres
      caller-save vs. callee-save, registre stockant la valeur de retour),

    - un jeu d'instruction bas niveau.

    *Attention* : les six premiers arguments sont passés par %rdi, %rsi, %rdx,
    %rcx, %r8, %r9. Donc les arguments déclarés et passés explicitement en
    Retrolix sont ceux qui viennent des fonctions sources (Fopix) qui avaient
    plus de six arguments au départ !

*** x86-64
    Le code est contenu dans [[file://../flap/src/x86-64][src/x86-64/]], et
    l'AST qui nous intéresse est dans
    [[file://../flap/src/x86-64/x86_64_AST.ml][x86_64_AST.ml]]. Pas d'interprète
    ou parser.

    On a vu les points saillants de l'assembleur x86-64 la dernière fois.

    Remarque : comme on utilise GCC pour l'assemblage et l'édition de liens, nos
    programmes assembleurs doivent disposer d'une fonction main().

    *Attention* : l'AST est *trop permissif* ! Il permet d'écrire du code qui
    n'assemble pas, par exemple ~movq (%rsp), (%rsp)~. Éviter de générer ce
    genre de code fait partie de votre travail.

*** Différences entre Retrolix et x86-64
    - des chaînes litérales en Retrolix,

    - en Retrolix, pas de fonction main(), le point d'entrée du programme est la
      séquence des blocs d'initialisation de ses variables globales,

    - pas de variables en x86-64,

    - jeu d'instructions assez différent : Retrolix est plutôt RISC mais x86-64
      est très CISC ; par exemple :

      * trois adresses vs. deux adresses,

      * modes d'adressage et opérandes mémoires limités en x86-64,

      * bizarreries en x86-64, par exemple la division.
* Cours 10 <2022-11-21>
** De Retrolix à x86-64 (suite)
*** Traduire Retrolix vers x86-64
    Certaines des différences que nous venons de décrire ne sont pas
    essentielles, et sont donc déjà traitées pour vous (chaînes litérales,
    génération d'un main, ...). On va se concentrer sur deux points :

    - la traduction des constructions Retrolix en assembleur x86-64,

    - la gestion des variables et de la pile.

    La passe de traduction est dans
    [[file://../flap/src/x86-64/retrolixToX86_64.ml][retrolixToX86_64.ml]]. Vous
    devez remplacer les ~failwith "Students!"~ avec le code approprié.

    Il s'agit essentiellement d'implémenter deux modules, ~InstructionSelector~
    et ~FrameManager~. Le premier se charge de la traduction de construction
    atomiques de Retrolix en x86-64, le second de la gestion de la pile et des
    variables. Le second va naturellement faire appel au premier.

    *Attention* : dans ce jalon, on se concentrera sur la *correction* du code
    généré. Produire du code optimisé est un objectif secondaire.
**** Points à gérer
***** Bases de la gestion de la pile
      Considérons la fonction ci-dessous.

#+BEGIN_SRC
      def f(x, y)
      local a, b, c:
        ...
      end
#+END_SRC

      En suivant l'ABI System V, à quoi doit ressembler son cadre de pile après
      l'exécution de son prologue ? Quel est le code du prologue, d'ailleurs ?
      De l'épilogue ?
****** Indications

     Prologue :

#+BEGIN_SRC asm
       pushq %rbp
       movq %rsp, %rbp
       subq $24, %rsp
#+END_SRC

     Épilogue :

#+BEGIN_SRC asm
       addq $24, %rsp
       popq %rbp
       ret
#+END_SRC

     Disposition de la pile :

     | cadre parent |        |
     |--------------+--------|
     | arg y        |        |
     | arg x        |        |
     | saved %rip   |        |
     | saved %rbp   | <- rbp |
     | var a        |        |
     | var b        |        |
     | var c        | <- rsp |

     Notons que l'ABI nous laisse le choix de l'ordre des variables locales.

***** Bases de la traduction
      Comment traduire les instructions Retrolix suivantes ?

#+BEGIN_SRC asm
        %rax <- load 42;
#+END_SRC

#+BEGIN_SRC asm
        %rax <- add %rax, %rbx;
#+END_SRC

#+BEGIN_SRC asm
        %rax <- add %rbx, %rcx;
#+END_SRC

#+BEGIN_SRC asm
        %rax <- div %rbx, %rcx;
#+END_SRC

      Comment traduire l'instruction suivante, si a est une variable locale (par
      exemple la première) ? Le premier paramètre de la fonction Retrolix
      courante ? Une variable globale ?

#+BEGIN_SRC asm
         a <- load 42;
#+END_SRC

      Dans les instructions ci-dessous, on se place dans le corps d'une fonction
      dont les variables locales sont a, b et c, déclarées dans cet ordre.

#+BEGIN_SRC asm
         %rax <- add %rax, a;
#+END_SRC

#+BEGIN_SRC asm
         a <- add a, %rax;
#+END_SRC

#+BEGIN_SRC asm
         a <- add a, b;
#+END_SRC

#+BEGIN_SRC asm
         a <- add b, c;
#+END_SRC

****** Indications
       Pour les instructions élémentaires :

#+BEGIN_SRC asm
        movq $42, %rax
#+END_SRC

#+BEGIN_SRC asm
        addq %rbx, %rax
#+END_SRC

#+BEGIN_SRC asm
        movq %rbx, %rax
        addq %rcx, %rax
#+END_SRC

#+BEGIN_SRC asm
        movq %rdx, %r15
        movq %rbx, %rax
        cqto
        idivq %rcx
        mocq %r15, %rdx
#+END_SRC

      Traduction de ~a <- load 42~ lorsque ~a~ est :

      - la première variable locale dans la pile

#+BEGIN_SRC asm
         movq $42, -8(%rbp)
#+END_SRC

      - un paramètre Retrolix (le premier)

#+BEGIN_SRC asm
         movq $42, 16(%rbp)
#+END_SRC

      - une variable globale, stockée au label ~a~

#+BEGIN_SRC asm
         movq $42, a
#+END_SRC

      La traduction du reste des exemples :

#+BEGIN_SRC asm
         addq -8(%rbp), %rax
#+END_SRC

#+BEGIN_SRC asm
         addq %rax, -8(%rbp)
#+END_SRC

#+BEGIN_SRC asm
         movq -16(%rbp), %r15
         addq %r15, -8(%rbp)
#+END_SRC

#+BEGIN_SRC asm
         movq -24(%rbp), %r15
         addq -16(%rbp), %r15
         movq %r15, -8(%rbp)
#+END_SRC

***** Convention d'appel

      Comment traduire les appels de fonction ?

#+BEGIN_SRC asm
      def f()
        call g(23, %rax, %rbx)
#+END_SRC

      N'oubliez pas qu'il faut aussi traiter les appels de fonction *terminaux*.

****** Indications

#+BEGIN_SRC asm
f:     pushq %rbp
       movq %rsp, %rbp
       subq $8, %rsp    # sert à aligner la pile sur 16 octets pour le call
       pushq %rbx       # argument 3
       pushq %rax       # argument 2
       pushq $23        # argument 1
       call g           # appel (la pile est bien alignée sur 16 octets !)
       addq $32, %rsp   # libère les arguments sur la pile
       movq %rbp, %rsp
       popq %rbp
       ret
#+END_SRC

#+BEGIN_SRC asm
      def f()
        call g(23, %rax, %rbx) tail
#+END_SRC
** De Fopix à Retrolix
*** Présentation de Fopix
    Lecture de l'AST Fopix présent dans le fichier
    [[file://../flap/src/fopix/fopixAST.ml][fopixAST.ml]].
*** Fopix et Retrolix, similarités et différences
**** Similarités
    - Langages de premier ordre avec possibilité de saut indirect.

    - Litéraux identiques.
**** Différences
    - Retrolix a des registres machines.

    - Retrolix suit la convention d'appel machine.

    - Fopix est un langage à base d'expressions de profondeur arbitraire plutôt
      que d'instructions au format trois adresses.

    - Fopix a des && et des || court-circuits.

    - Fopix dispose d'instructions de gestion du flot de contrôle structurées.

    - Fopix a des déclarations locales internes aux fonctions, tandis que
      Retrolix ne dispose que d'un espace de nom pour toute fonction (ou
      initialiseur de variable globale).

    - Plus subtil : Fopix accède à la mémoire à travers des blocs. La syntaxe
      concrète des affectations prend la forme ~block_e[index_e] := val_e~
      tandis que les déréférences prennent la forme ~block_e[index_e]~. Ces
      constructions sont traduites vers des appels à ~write_block()~ et
      ~read_block()~ dans la syntaxe abstraite, cf. ~fopixInterpreter.ml~.
**** Aparté : un détail négligé en Retrolix et x86-64
     Les programmes que nous allons compiler vont reposer sur un exécutif
     (/runtime/), c'est à dire du code d'infrastructure.

     En ce qui nous concerne, ce /runtime/ prendra la forme d'un fichier écrit
     en C et concernera notamment des fonctions utiles à la gestion mémoire.

 #+BEGIN_SRC C
       location_t allocate_block(int64_t size);
       value_t read_block(location_t block, int64_t index);
       void write_block(location_t block, int64_t index, value_t v);
 #+END_SRC

     Il contient aussi du code d'entrée/sortie, ou de comparaisons de certains
     types de données (notamment les chaînes de caractères).

     *Attention* : la grande différence entre le tas et la pile, en termes de
     gestion de la mémoire, est que les données sur la pile sont libérées
     automatiquement en fonction du flot de contrôle (une fonction libère son
     cadre de pile quand elle retourne à son appelant). Pour libérer la mémoire
     du tas, on utilise typiquement un /garbage-collector/ (ou ramasse-miettes,
     ou glanneur de cellules).

     (Flap ne comprend pas de ramasse-miettes actuellement.)

     Un ramasse-miettes parcourt la mémoire pour détecter si des blocs de
     mémoire ne sont plus /atteignables/. Un bloc est /atteignable/ si l'on peut
     obtenir son adresse en lisant des pointeurs depuis les registres et la
     pile. Un bloc qui n'est pas atteignable peut être libéré, puisque notre
     programme ne pourra plus jamais y accéder.
*** Quelles sont les difficultés de la traduction de Fopix en Retrolix ?
**** Passage des expressions au code à trois adresses ; structures de contrôle
    Comment compiler vers Retrolix les expressions Fopix suivantes ?

    On supposera que le résultat de chaque expression doit être stocké vers une
    variable locale baptisée "r" et, bien sûr, utiliser autant de variables
    locales que nécessaire (elles sont là pour ça).

    À ce stade, on ne cherche pas *du tout* à optimiser le code, mais plutôt à
    trouver un schéma de compilation mécanique qui soit facile à implémenter.

    ~1 - (3 * 4)~

    ~x >= 0~

    ~if x = 0 then 0 else y / x~

    ~(while (x[0] >= 0) (x[0] := x[0] - 1)); x[0]~
**** Solutions
     Toute instruction Retrolix doit être précédée d'une étiquette, mais on les
     omet ci-dessous les étiquettes superflues. Tous les ~xI~ sont des variables
     locales préalablement déclarées.

     Premier exemple :

#+BEGIN_SRC
       x1 <- copy 1;
       x2 <- copy 3;
       x3 <- copy 4;
       x4 <- mul x2, x3;
       r  <- add x1, x4;
#+END_SRC

     Troisième exemple :

#+BEGIN_SRC
       x1 <- copy 1;
       x2 <- copy x;
       x3 <- eq x1, x2;
       jumpif eq x3, 0 -> lE, lT
   lT: r <- copy 0;
       jmp lK:
   lE: x4 <- y;
       x5 <- x;
       r <- div x4, x5;
   lK:
#+END_SRC

     Deuxième exemple :

#+BEGIN_SRC
       lT: x1 <- read_block(x, 0);
           x2 <- copy 0;
           x3 <- gte x1, x2;
           jumpif eq x3, 0 -> lK, lB
       lB: x4 <- read_block(x, 0);
           x5 <- sub x4, 1;
           write_block(x, 0, x5);
           jump lT
       lK: r <- read_block(x, 0);
#+END_SRC

     *Remarque* : ces solutions sont volontairement naïves. Un attrait des
     compilateurs optimisants est de permettre, au moins dans une certaine
     mesure, de séparer la correction de l'efficicacité. Concrètement, on peut
     générer du code simple qui sera optimisé par une passe ultérieure. En
     particulier, le code montré ci-dessus peut être facilement généré par une
     fonction récursive.
