#+TITLE: Compilation 2022/2023 -- Journal du cours
#+AUTHOR: Adrien Guatto
#+EMAIL: guatto@irif.org
#+LANGUAGE: fr
#+OPTIONS: ^:nil p:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \hypersetup{hidelinks}
#+LATEX_HEADER: \usepackage[french]{babel}
# (org-latex-export-to-pdf)

  Ce fichier est disponible au
  [[https://www.irif.fr/~guatto/teaching/22-23/compilation/journal.html][format
  HTML]].

* Cours 1 : Introduction <2022-09-12>
** Présentation
   Bienvenue en Master 1 !

   |--------+--------------------------------------------+---------------------+---------|
   | Séance | Enseignant                                 | Horaire             | Salle   |
   |--------+--------------------------------------------+---------------------+---------|
   | Cours  | [[mailto:guatto@irif.fr][Adrien Guatto]]   | lundi 10h45-12h45   | SG 1003 |
   | TP     | [[mailto:haberm@irif.fr][Peter Habermehl]] | vendredi 8h30-10h30 | SG 2031 |
   |--------+--------------------------------------------+---------------------+---------|

   *Attention* : les séances de TP commencent la même semaine que les cours !
** Contenu et objectifs du cours
*** Introduction au cours
    En licence, vous avez acquis les bases de l'informatique : appris à
    programmer dans plusieurs langages, découvert l'algorithmique sous diverses
    formes, vous êtes familiarisés avec l'utilisation d'un système UNIX, etc.

    En master, on ouvre les boîtes noires ! Par exemple, le cours d'architecture
    des ordinateurs vous initie au fonctionnement interne d'un processeur.

    Dans ce cours, on ouvre la boîte noire des langages de programmation :
    comment fonctionne un compilateur ? Comment passer d'un fichier texte
    contenant du code source à un programme que votre processeur peut exécuter ?

    Comprendre le fonctionnement des compilateurs est l'objectif affiché du
    cours. Il y en a un deuxième, un peu caché : vous faire programmer, et
    beaucoup ! Vous allez écrire un compilateur, en OCaml, tout au long du
    semestre, en binôme, de façon guidée. Vous allez pour ce faire utiliser des
    méthodes et outils de développement modernes : gestion de version, tests,
    intégration continue, etc.
*** Pourquoi étudier la compilation ?
    Ce n'est pas une compétence directement mobilisable dans la plupart des
    emplois de développeur, même si la demande pour des experts en compilation
    est forte à l'international (exemple : compilation de JavaScript).

    Mais comprendre comment fonctionne un compilateur vous transformera en des
    programmeurs plus mûrs, qui maîtrisent les fondements de leurs outils. C'est
    une aide concrète lorsqu'on programme, et notamment lorsqu'on débogue et
    qu'on a besoin de regarder ``sous le capot''.

    De plus, la compilation est un sujet pluridisciplinaire :
    - architecture des ordinateurs,
    - théorie des graphes
    - théorie des langages et automates,
    - sémantique des langages de programmation,
    - génie logiciel,
    - méthodes formelles...
    Vous allez donc mettre en pratique et revisiter certains concepts que vous
    avez vu dans d'autres cours, ce qui peut vous aider à les assimiler.

    Il va sans dire que la réalisation du projet va aussi beaucoup augmenter
    votre expérience de la programmation. Ce sera pour la majorité d'entre vous
    l'occasion de vous confronter pour la première fois à une base de code
    réaliste !
** Fonctionnement du cours
   Vous avez tous reçu une copie de la description du cours (son /syllabus/,
   dans le jargon), aussi disponible en ligne sur la page du cours. Prenons le
   temps de le lire ensemble.

   Il se dégage plusieurs principes.

   - Les séances de cours sont centrées sur la réalisation du projet, qui
     oriente les concepts que je vais présenter et nos discussions. Elles se
     veulent interactives et ouvertes à la discussion.

   - Le projet est structuré en grandes étapes indépendantes, les /jalons/, qui
     prennent la forme de code à trou : il faudra lire autant qu'écrire !

   - Vous aurez les énoncés des jalons rapidement, et chaque séance de cours
     débutera par 15 à 30 minutes de travail collectif au sujet des questions
     que vous aurez préparées au sujet des jalons.

   - Le bon fonctionnement des jalons sera évalué par une batterie de tests
     automatiques.

   Pour que le cours fonctionne, vos enseignants attendent de vous :

   - que vous travailliez de façon continue et régulière tout le semestre,

   - que vous rendiez vos jalons à temps (toutes les trois semaines environ),

   - que vous prêtiez attention à la qualité du code,

   - en cours : que vous preniez des notes tout en réfléchissant et questionnant
     de façon critique la discussion,

   - en TP : que vous posiez des questions et discutiez avec l'enseignant et vos
     camarades,

   - chez vous : que vous lisiez le code du projet ainsi que les documents
     obligatoires et conseillées, que vous programmiez.

   L'évaluation se fera sur votre compréhension du projet, estimée pour 70% par
   la soutenance, pour 30% par un examen. La soutenance est individuelle, on
   vous demandera d'expliquer votre code, et la qualité de celui-ci sera prise
   en compte.
** Introduction à la compilation : le micro-langage Marthe
   Le reste de la séance est consacré à la lecture et discussion d'un
   micro-langage de programmation, Marthe. Voir le fichier
   [[file:cours-01/marthe.ml][marthe.ml]].
** À préparer pour le prochain TP et le prochain cours
*** TODO Prochaine séance de travaux pratiques
    - Venir avec son ordinateur portable, vendredi
    - S'assurer que celui-ci dispose d'un environnement de développement OCaml
      fonctionnel (compilateur OCaml, OPAM, dune).
*** TODO S'inscrire sur la liste de diffusion du cours
    https://listes.u-paris.fr/wws/info/m1.2022.compilation.info
*** TODO Prochain séance de cours
    - Finir la gestion des commentaires dans ~marthe.ml~.
* Cours 2 <2022-09-19>
** Message de service
   La liste a été configurée correctement, les étudiants et étudiantes peuvent
   désormais s'inscrire avec leur adresse courriel favorite.

   https://listes.u-paris.fr/wws/info/m1.2022.compilation.info
** Le retour de Marthe
   Dans [[file:cours-01/marthe.ml][marthe.ml]], on ajoute les commentaires à
   l'analyseur lexical, et on lit l'analyseur syntaxique.
** Le cours 2
   Voir les [[file:cours-02/cours-02-parsing.pdf][transparents]].
** À préparer pour le prochain TP et le prochain cours
*** TODO Lire la documentation des outils ocamllex et Menhir
    - [[https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html]]
    - [[http://pauillac.inria.fr/~fpottier/menhir/manual.pdf]]
*** TODO Préparer le dépôt du projet
    - Forker le dépôt Git du projet
    https://gaufre.informatique.univ-paris-diderot.fr/aguatto/compilation-m1-2022
    - Passer votre fork du dépôt en visibilité privée
    - Ajouter l'accès à l'équipe enseignante
      - Adrien Guatto @aguatto
      - Peter Habermehl @habermeh
    - Remplir le fichier AUTEURS du dépôt
* Cours 03 <2022-09-26>
** Introduction au jalon 1 et au compilateur flap
   Voir le [[file:../flap][code]] du compilateur Flap, ainsi que l'énoncé du
   [[../jalons/jalon-1.pdf][jalon 1]].
** La prochaine fois
   - On terminera de lire ~marthe.ml~.

   - On commencera une séquence de cours au sujet des langages de programmation.
* Cours 04 <2022-10-03>
** Suivi du projet
*** Pourquoi n'y a-t-il pas de ~if <expr> then <expr>~ dans l'AST Hopix ?
    Une partie du /sucre syntaxique/ est éliminée lors de l'analyse
    syntaxique. C'est le cas du ~if <expr> then <expr>~ qui se /désucre/ de la
    même façon que celui d'OCaml.
*** Comment gérer les positions ?
    Menhir ne connaît pas le fichier source, uniquement le ~lexbuf~. C'est donc
    à l'analyseur lexical de remplir ce dernier correctement pour que
    l'analyseur syntaxique puisse avoir accès à l'information de position. Voir
    le type ~Lexing.lexbuf~ pour cette information de position.

    L'analyseur lexical doit essentiellement détecter les nouvelles lignes pour
    mettre à jour le ~lexbuf~. Cf. ~Lexing.new_line~, déjà utilisée dans le
    fichier l'analyseur lexical fourni.

    Les règles de l'analyseur syntaxique peut ensuite utiliser les variables
    Menhir ~$startpos~ et ~$endpos~. Dans le fichier fourni, leur utilisation
    passera par la règle paramétrique ~located(X)~.

    #+BEGIN_VERBATIM
%inline located(X): x=X {
  Position.with_poss $startpos $endpos x
}
    #+END_VERBATIM

    On peut utiliser cette règle pour analyser une valeur de type ~'a
    located~. Par exemple, le non-terminal ~located(expression)~ produit une
    valeur de type ~'a located~.
*** Questions diverses
    J'apporte quelques précisions à l'énoncé du jalon 1.
** Introduction à la théorie des langages de programmation
   Voir la première partie des
   [[file:cours-04-à-06/cours-04-à-06-intro-semantique-typage.pdf][transparents]]
   dédiés. La substitution (derniers transparents) sera traitée à la prochaine
   séance.
* Cours 05 <2022-10-10>
** Suivi du projet
*** À propos des erreurs
    Les erreurs doivent de syntaxe doivent être levées via la fonction
    ~Error.error~, à laquelle il faut passer une position valide.
*** À propos des positions
    Les positions générées dans les messages d'erreur peuvent dépendre de
    détails de la structure de votre grammaire. Il n'est donc pas gênant que
    vous n'ayez pas exactement les mêmes messages que ceux présents dans les
    tests fournis avec le jalon.
** Introduction à la théorie des langages de programmation
   Voir la deuxième partie des
   [[file:cours-04-à-06/cours-04-à-06-intro-semantique-typage.pdf][transparents]]
   dédiés. On a traité la substitution de la première partie.
